<!DOCTYPE HTML>
<html>
<head>
	<script>
/**
 * Global variables for scalable content.
 */
 var width = 900;
 var height = 2 * width / 3;
 var globalFont = 'Arial';

 var functionStrokeWidth = width / 90;
 var functionHalfStrokeWidth = functionStrokeWidth / 2;
 var functionTotalSideLength = width / 20;
 var functionRectSideLength = functionTotalSideLength - functionStrokeWidth;
 var functionColor = '#508C37';

 var valueSideLength = functionTotalSideLength / 1.414;
 var valueXYColor = 'gray'
 var valueTimeColor = 'gold'
 var valueConstantColor = 'purple'

 var imageBoxSideLength = width / 80;
 var imageBoxColor = 'white'
 var functionImageBoxOffset = width / 300;
 var valueImageBoxOffset = width / 31;
 var renderSideLength = width / 18;

 var outletXOffset = width / 255;
 var outletYOffset = functionRectSideLength / 3;
 var outletColor =  '#FFC440';

 var lineStrokeWidth = 2;

 var menuHeight = width / 9; 
 var menuCornerWidth = width / 5;
 var valMenuXSpacing = width / 32;
 var functMenuXSpacing = width / 68;
 var menuYspacing = width * 11/360;
 var buttonWidth = width / 10;
 var menuFunctsXStart = 2 * (buttonWidth - functionRectSideLength) + menuCornerWidth- functionTotalSideLength / 2;
 var menuFunctsXEnd = width - buttonWidth + functionRectSideLength / 2;
 var menuValuesXStart = menuCornerWidth + buttonWidth / 2;
 var menuAnimDuration = 1;

	var toolboxWidth = width / 18; // 50
	var toolboxHeight = width / 4.1; // 180
	var toolboxShift = toolboxWidth / 5; // 10
	var toolboxButtonSize = width / 30; // 30

	</script>

	<script>
/**
	* Arrays of the basic function and value names, and tables of their specific settings
	*/

	var funNames = ['add', 'multiply', 'negate', 'sine', 'cosine', 'absolute', 'average', 'sign', 'rgb'];
	var functions = {
		add: 			{rep: '+', 	 max: 20, min: 2, prefix: '', 		separator: '+'},
		multiply: {rep: '*', 	 max: 20, min: 2, prefix: '', 		separator: '*'},
		negate: 	{rep: '-', 	 max: 1,  min: 1, prefix: '-', 		separator: ' '},
		sine: 		{rep: 'sin', max: 1,  min: 1, prefix: 'sin', 	separator: ' '},
		cosine: 	{rep: 'cos', max: 1,  min: 1, prefix: 'cos', 	separator: ' '},
		absolute: {rep: 'abs', max: 1,  min: 1, prefix: 'abs', 	separator: ' '},
		average: 	{rep: 'ave', max: 20, min: 2, prefix: 'ave', 	separator: ','},
		sign: 		{rep: 'sign',max: 1,  min: 1, prefix: 'sign', separator: ' '},
		wrap: 		{rep: 'wrap',max: 1,  min: 1, prefix: 'wrap', separator: ' '},
		rgb: 			{rep: 'rgb', max: 3,  min: 3, prefix: 'rgb', 	separator: ','}
	}
	var valNames = ['x', 'y', 'second', 'minute', 'hour', 'day', 'constant'];
	var values = {
		x: 				{rep: 'x', 	 max: 20, min: 2, color: valueXYColor},
		y: 				{rep: 'y', 	 max: 20, min: 2, color: valueXYColor},
		second: 	{rep: 't.s', max: 1,  min: 1, color: valueTimeColor},
		minute:		{rep: 't.m', max: 1,  min: 1, color: valueTimeColor},
		hour: 		{rep: 't.h', max: 1,  min: 1,	color: valueTimeColor},
		day: 			{rep: 't.d', max: 1,  min: 1, color: valueTimeColor},
		constant:	{rep: '', 	 max: 20, min: 2, color: valueConstantColor},
	}
	</script>
	

	<style>
	body {
		margin: 0px;
		padding: 0px;
	} 
	#container {
		background-color: rgb(241, 248, 255);
		width: 900px;
		height: 600px;
	}
	</style>
</head>
<body>
	<div id="container"></div>
	<script src="http://www.cs.grinnell.edu/~rebelsky/Glimmer/Summer2014/MathOverImages/Sandbox/render.js">
	</script>
	<script src="http://d3lp1msu2r81bx.cloudfront.net/kjs/js/lib/kinetic-v5.1.0.min.js">
	</script>
	<script defer="defer">

	var stage = new Kinetic.Stage({
		container: 'container',
		width: width,
		height: height
	});


/**
 * Layers of the workspace:
 * 1. The line layer holds connecting lines between nodes in the work area.
 * 2. The menu layer holds the buttons that users can click on to drag a new node into
 *		the work area.
 * 3. The menuButton layer holds the super buttons that are used to expand the menus.
 * 4. The work layer holds all active nodes that are either connected or available to
 * 		be connected.
 * 5. The border layer stores static elements of the page such as dividing lines.
 * 6. The drag layer holds nodes while they are being moved about the workspace.
 */

 var lineLayer = new Kinetic.Layer();
 var menuLayer = new Kinetic.Layer();
 var menuButtonLayer = new Kinetic.Layer();
 var toolboxLayer = new Kinetic.Layer();
 var workLayer = new Kinetic.Layer();
 var borderLayer = new Kinetic.Layer();
 var dragLayer = new Kinetic.Layer();

/**
 * Add the layers to the stage. The top layer is the one most recently added, and
 * objects within a layer follow the same logic.
 */
 stage.add(lineLayer);
 stage.add(menuLayer);
 stage.add(menuButtonLayer);
 stage.add(toolboxLayer);
 stage.add(workLayer);
 stage.add(borderLayer);
 stage.add(dragLayer);

  //UTILITY FUNCTIONS

/*
isFunction determines if target is a functionGroup and returns a boolean value. 
target is an object.
*/
var isFunction = function(target) {
	return (target.attrs.maxInputs != null);
};

/*
isValue determines if target is a valueGroup and returns a boolean value. 
target is an object.
*/
var isValue = function(target) {
	return (target.attrs.maxInputs == null);
};

/*
isOutlet determines if target is an outletGroup and returns a boolean value. 
target is an object.
*/
var isOutlet = function(target) {
	return (target.name() != null && target.attrs.name.substring(0,6) == 'outlet');
};

/*
isLine determines if target is a line and returns a boolean value. 
target is an object.
*/
var isLine = function(target) {
	return (target.attrs.outlet != null);
};

/*
isImageBox determines if target is an image box and returns a boolean value. 
target is an object.
*/
var isImageBox = function(target) {
	return (target.name() != null && target.attrs.name == 'imageBox');
}

/*
isDrawTool determines if target is the drawing tool on the pallette and returns a boolean value. 
target is an object.
*/
var isDrawTool = function(target) {
	return (target.name() != null && target.attrs.name == 'draw');
}

/*
isDeleteTool determines if target is the drawing tool on the pallette and returns a boolean value. 
target is an object.
*/
var isDeleteTool = function(target) {
	return (target.name() != null && target.attrs.name == 'delete');
}

/*
isToolControl determines if target is the tool group controller on the pallette and returns a boolean value. 
target is an object.
*/
var isToolControl = function(target) {
	return (target.name() != null && target.attrs.name == 'toolControl');
}

/*
isRedoTool determines if target is the redo tool on the pallette and returns a boolean value. 
target is an object.
*/
var isRedoTool = function(target) {
	return (target.name() != null && target.attrs.name == 'redo');
}

/*
isUndoTool determines if target is the redo tool on the pallette and returns a boolean value. 
target is an object.
*/
var isUndoTool = function(target) {
	return (target.name() != null && target.attrs.name == 'undo');
}

/**
 * isRenderable takes a node, and returns true if it is a value group or a
 * function group with sufficient inputs, and false if it is a function group
 * with insufficient inputs.
 */
 var isRenderable = function(group) {
 	if (isValue(group)) {
 		return true;
 	} else {
 		var validInputs = 0;
 		for(var i = 3; i < group.children.length; i++) {
 			lineIn = group.children[i].attrs.lineIn;
 			if (lineIn != null && isRenderable(lineIn.attrs.source)) {
 				validInputs++;
 			}
 		}
 		return validInputs >= group.attrs.minInputs;
 	}
 }

 var isCycle = function(sourceGroup, outletGroup) {

 	var lineOut = outletGroup.attrs.lineOut;
 	if (lineOut.length === 0) {
 		return false;
 	}
 	for(var i = 0; i < lineOut.length; i++) {
 		if (sourceGroup == lineOut[i].attrs.outlet.parent) {
 			return true;
 		} else if (isCycle(sourceGroup, lineOut[i].attrs.outlet.parent) ) {
 			return true;
 		}
 	}
 	return false;
 }
	// CONSTRUCTORS

/*
	Function nodes and Value nodes are groups of objects. Members of groups can
	be accessed through the array 'group'.children[].
	Children are stored in the following order:
	0. Underlying Shape
	1. Text
	2. render box
	3+. Outlet nodes (only for functions)
	*/


/* 
	makeFunctionGroup takes a string funName, a key in the functions object above,
	an integer x, and an integer y, and returns the corresponding function node object,
	with top right corner at the given x, y coordinate.
	*/
	var makeFunctionGroup = function(funName, x, y) {
		/* create group that will contain information on the function and the shapes making up the representation on screen. */
		var newGroup = new Kinetic.Group({
			name: funName,
			x: x - functionHalfStrokeWidth,
			y: y,
			numInputs: 0, 
			maxInputs: functions[funName].max, 
			minInputs: functions[funName].min, 
			lineOut: [], 
			prefix: functions[funName].prefix, 
			separator: functions[funName].separator,
			renderFunction: null,
			visible: false,
			renderLayer: null
		});
		/* create rectangle shape */
		var newRect = new Kinetic.Rect({
			name: funName,
			x: functionHalfStrokeWidth,
			y: functionHalfStrokeWidth,
			width: functionRectSideLength,
			height: functionRectSideLength,
			fill: functionColor,
			lineJoin: 'round',
			stroke: functionColor,
			strokeWidth: functionStrokeWidth
		});
		newGroup.add(newRect);
		/* create text to be displayed on top of rectangle */
		var newText = new Kinetic.Text({
			text: functions[funName].rep,
			fontFamily: globalFont,
			fill: 'black',
			fontSize: 16,
			x: 0,
			y: functionTotalSideLength/2 - functionHalfStrokeWidth,
			width: functionTotalSideLength,
			align: 'center'
		});
		newGroup.add(newText);
		/* create small box in the bottom right corner. Originally is not visible.*/
		var newBox = new Kinetic.Rect({
			name: 'imageBox',
			x: functionRectSideLength + functionImageBoxOffset,
			y: functionRectSideLength + functionImageBoxOffset,
			width: imageBoxSideLength,
			height: imageBoxSideLength,
			fill: imageBoxColor,
			stroke: 'black',
			strokeWidth: .5,
			visible: false,
			expanded: false
		});
		newGroup.add(newBox);

		return newGroup;
	};


/*
	makeValueGroup takes a string valName, the name of a key in the values object above,
	an integer x, and an integer y, and returns the corresponding function node object,
	centered at (x + width / 40, y + width / 40).
	*/
	var makeValueGroup = function(valName, x, y) {
		/* create group that contains information on the value and shapes to be displayed. */
		var newGroup = new Kinetic.Group({
			name: valName,
			x: x,
			y: y,
			lineOut: [],
			visible: false,
			renderFunction: values[valName].rep,
			renderLayer: null
		});
		/* create diamond shape. */
		var newRect = new Kinetic.Rect({
			x: functionRectSideLength/2,
			y: 0,
			width: valueSideLength,
			height: valueSideLength,
			fill: values[valName].color,
			rotation: 45,
			name: valName
		});
		newGroup.add(newRect);
		/* create text to be displayed on diamond. */
		var newText = new Kinetic.Text({
			text: values[valName].rep,
			fontFamily: 'OpenSans',
			fill: 'black',
			fontSize: 16,
			x: 0,
			y: valueSideLength/2,
			width: functionRectSideLength,
			align: 'center'
		});
		newGroup.add(newText);
		/* create small box in bottom right corner. Originally not visible. */
		var newBox = new Kinetic.Rect({
			name: 'imageBox',
			x: valueImageBoxOffset,
			y: valueImageBoxOffset,
			width: imageBoxSideLength,
			height: imageBoxSideLength,
			fill: imageBoxColor,
			stroke: 'black',
			strokeWidth: .5,
			visible: false,
			expanded: false
		});
		newGroup.add(newBox);

		return newGroup;
	};

/*
	makeOutlet takes a function node object, functGroup, and returns an outlet node object 
	to be added to that group.
	It DOES NOT add the outlet to the group.
	*/
	var makeOutlet = function(functGroup) {
		var bezPoint = width / 50;
		var outlet = new Kinetic.Shape({
			sceneFunc: function(context) {
				context.beginPath();
				context.moveTo(0, 0);
				context.bezierCurveTo(-bezPoint, -bezPoint, -bezPoint, bezPoint, 0, 0);
				context.closePath();
				context.fillStrokeShape(this);
			},
			name: 'outlet' + (functGroup.children.length - 3),
			x:functGroup.children[0].x() + outletXOffset,
			y:functGroup.children[0].y() + (functGroup.children.length - 3) * outletYOffset + functionHalfStrokeWidth,
			fill: '#FFC440',
			stroke: 'black',
			strokeWidth: 1,
			lineIn: null
		});
		return outlet;
	};
/*
	makeLine takes either a functionGroup object or valueGroup object as input (source) and creates a line that begins at the left edge of source. 
	*/
	var makeLine = function(source) {
		var newLine = new Kinetic.Line({
			points: [
			source.x() + functionRectSideLength - 3,
			source.y() + functionTotalSideLength / 2,
			source.x() + functionTotalSideLength,
			source.y() + functionTotalSideLength / 2,
			],
			stroke: 'black',
			strokeWidth: lineStrokeWidth,
			source: source,
			sourceIndex: source.attrs.lineOut.length,
			outlet: null
		});
		return newLine;
	}
/*
makeMenuTween takes a node (target), an integer (xEnd), and a boolean (visibility). It returns a kinetic tween that will move target to xEnd, without changing y value; and with the visibility to the specified boolean values.*/
var makeMenuTween = function(target, xEnd, visibility) {
	return new Kinetic.Tween({
		node: target,
		duration: menuAnimDuration,
		x: xEnd,
		visible: visibility,
		easing: Kinetic.Easings.StrongEaseOut
	});
};

// METHODS

/*
	addOutlet takes a function group funGroup and adds an outlet to it, expanding the node if there is not enough space for the outlet.
	*/
	var addOutlet = function(funGroup) {
		if(funGroup.children.length - 3 < funGroup.attrs.maxInputs) {
			if(funGroup.children.length - 3 > 2) {
				funGroup.children[0].setAttr('height',
					funGroup.children[0].attrs.height + outletYOffset);
				funGroup.children[1].setAttr('y', funGroup.children[1].attrs.y + outletYOffset / 2);
				funGroup.children[2].setAttr('y', funGroup.children[2].attrs.y + outletYOffset);
			}
			var newOutlet = makeOutlet(funGroup);
			funGroup.add(newOutlet);
			workLayer.draw();
		}
	};


/**
 * findRenderFunction takes a group and, if the group has sufficient inputs, finds the 
 * renderFunction that should be used to create an image for output.
 * NOTE: this will always recalculate the entire function
 */
 var findRenderFunction = function(group) {
 	group.attrs.renderFunction = functions[group.attrs.name].prefix + '(';
 		for(var i = 3; i < group.children.length; i++) {
 			if(group.children[i].attrs.lineIn != null) {
 				group.attrs.renderFunction += group.children[i].attrs.lineIn.attrs.source.attrs.renderFunction;
 				group.attrs.renderFunction += functions[group.attrs.name].separator
 			}
		} // add each element to the equation
		group.attrs.renderFunction = group.attrs.renderFunction.substring(0, group.attrs.renderFunction.length - 1) + ')';
};

/**
 * assertRenderable takes a function group and checks if it is renderable. If true, it finds the renderFunction for the group, makes the imageBox visible and returns true. If false, it makes the imageBox invisible and returns false.
 */
 var assertRenderable = function(group) {
 	if (isRenderable(group)) {
 		findRenderFunction(group);
 		group.children[2].setAttr('visible', true);
 		return true;
 	} else {
 		group.children[2].setAttr('visible', false);
 		return false;
 	}
 }

/*
	renderCanvas takes a function or value group and renders a 50 by 50 image starting where the image box is located.  
	*/
	var renderCanvas = function(group) {
		var currLayer = group.attrs.renderLayer; 
		if (currLayer == null){
			currLayer = new Kinetic.Layer();
			group.setAttr('renderLayer', currLayer);
			stage.add(currLayer);
		} // if 
		group.children[2].setAttrs({
			width: renderSideLength,
			height: renderSideLength
		});
		var box = group.children[2];
		canvas = currLayer.canvas._canvas;
		renderFun(MOIbody2fun(group.attrs.renderFunction), canvas, group.x() + box.x(), group.y() + box.y(), renderSideLength, renderSideLength);
	};

/**
 * updateForward takes a group and makes sure all groups for which it is a source are
 * accurate. To be used whenever a function's inputs are changed, or when a node is
 * deleted.
 */
 var updateForward = function(group) {
 	for (var i = 0; i < group.attrs.lineOut.length; i++) {
 		var lineOutGroup = group.attrs.lineOut[i].attrs.outlet.parent;
 		assertRenderable(lineOutGroup);
 		updateForward(lineOutGroup);
 	}
 };

	// Create functions to Move Menu Items
	/* move the valueGroups in the menu to their original location. */
	var moveValueNodesIn = function() {
		for (var i = 0; i < menuValues.length; i++) {
			var moveValue = makeMenuTween(menuValues[i], menuValuesXStart, false);
			moveValue.play();
		}
	};
	/* move the valueGroups to their expanded location. */
	var expandValueNodes = function() {
		for (var i = 0; i < menuValues.length; i++) {
			var moveValue = makeMenuTween(menuValues[i], menuCornerWidth + buttonWidth + valMenuXSpacing + i * (valMenuXSpacing + functionTotalSideLength), true);
			moveValue.play();
		}
	};
	/* move the functionGroups to their original position. */
	var moveFunctionNodesIn = function() {
		for (var i = 0; i < menuFunctions.length; i++) {
			var moveFunction = makeMenuTween(menuFunctions[i], menuFunctsXStart, false);
			moveFunction.play();
		}
	};
	/* move the functionGroups to the right of the screen. (For when values are expanded).*/
	var moveFunctionNodesRight = function() {
		for (var i = 0; i < menuFunctions.length; i++) {
			var moveFunction = makeMenuTween(menuFunctions[i], menuFunctsXEnd, false);
			moveFunction.play();
		}
	};
	/* move the functionGroups to their expanded position. */
	var expandFunctionNodes = function() {
		for (var i = 0; i < menuFunctions.length; i++) {
			var moveFunction = makeMenuTween(menuFunctions[i], menuCornerWidth + 2 * buttonWidth + functMenuXSpacing + i * (functMenuXSpacing + functionTotalSideLength), true)
			moveFunction.play();
		}
	}
	/* move the functionsButton to the right of the screen (for when values are expanded). */
	var moveFunctionsButtonRight = function() {
		var moveButton = makeMenuTween(functionsButton, width - buttonWidth, true)
		moveButton.play();
	};
	/* move the functionsButon to it's original position. */
	var moveFunctionsButtonLeft = function() {
		var moveButton = makeMenuTween(functionsButton, menuCornerWidth + buttonWidth, true)
		moveButton.play();
	};

	var shadeButton = function(target) {
		if (target.attrs.working) {
			target.setAttrs({
				shadowEnabled: false,
				working: false
			});
		}
		else {
			target.setAttrs({
				shadowEnabled: true,
				working: true
			});
		}
	};
/*
	var unshadeOthers = function(target) {
		var group = target.getParent();
		if (isDrawTool(target)) {
			for( var i = 1; i < 4; i++)
				group.children[i].setAttrs({
					shadowEnabled: false,
					working: false
				});
		} else if (isDeleteTool(target)) {
			group.children[0].setAttrs({
				shadowEnabled: false,
				working: false
			});
			for( var i = 2; i < 4; i++)
				group.children[i].setAttrs({
					shadowEnabled: false,
					working: false
				});
		} else if (isRedoTool(target)) {
			for( var i = 0; i < 2; i++)
				group.children[i].setAttrs({
					shadowEnabled: false,
					working: false
				});
			group.children[3].setAttrs({
				shadowEnabled: false,
				working: false
			});
		} else if (isUndoTool(target)) {
			for( var i = 0; i < 3; i++)
				group.children[i].setAttrs({
					shadowEnabled: false,
					working: false
				});
		}
	};
	*/
	/* disableButton take a tool group from the tool box, turns off its functionality and disables its shadow. */
	var disableTool = function(toolGroup) {
		toolGroup.children[0].setAttr('shadowEnabled', false);
		var name = toolGroup.name();
		if (name == 'workTool') {
			workToolOn = false;
		} 
		else if (name == 'lineTool') {
			lineToolOn = false;
		}
		else {
			deleteToolOn = false;
		}
	};

//SETUP STAGE

/* create and add menu border */
var borderLine = new Kinetic.Line({
	points: [0, menuHeight, width, menuHeight],
	stroke: 'black',
	strokeWidth: 2
});

borderLayer.add(borderLine);
borderLayer.draw();

/* create and add menu buttons */
var valuesButton = new Kinetic.Group({
	x: menuCornerWidth
});
menuButtonLayer.add(valuesButton);

var valuesButtonBox = new Kinetic.Rect({
	x:0,
	y:0,
	width: buttonWidth,
	height: menuHeight,
	fill: 'lavender',
	stroke: 'black',
	strokeWidth: 2
});
valuesButton.add(valuesButtonBox);

var valuesButtonRect = new Kinetic.Rect({
	x: buttonWidth / 2,
	y: menuHeight / 4,
	width: valueSideLength,
	height: valueSideLength,
	fill: 'purple',
	rotation: 45,
});
valuesButton.add(valuesButtonRect);

var valuesButtonText = new Kinetic.Text({
	text: 'add a value',
	x: 0,
	y: menuHeight / 2 + menuHeight / 4,
	width: buttonWidth,
	height: menuHeight / 4,
	fill: 'black',
	align: 'center'
});
valuesButton.add(valuesButtonText);

var functionsButton = new Kinetic.Group({
	x: menuCornerWidth + buttonWidth
});
menuButtonLayer.add(functionsButton);

var functionsButtonBox = new Kinetic.Rect({
	x:0,
	y:0,
	width: buttonWidth,
	height: menuHeight,
	fill: '#D7EBCF',
	stroke: 'black',
	strokeWidth: 2
});
functionsButton.add(functionsButtonBox);

var functionsButtonRect = new Kinetic.Rect({
	x: buttonWidth / 2 - functionRectSideLength / 2,
	y: menuHeight / 4,
	width: functionRectSideLength,
	height: functionRectSideLength,
	fill: functionColor,
	lineJoin: 'round',
	stroke: functionColor,
	strokeWidth: functionStrokeWidth
});
functionsButton.add(functionsButtonRect);

var functionsButtonText = new Kinetic.Text({
	text: 'add a function',
	x: 0,
	y: menuHeight / 2 + menuHeight / 4,
	width: buttonWidth,
	height: menuHeight / 4,
	fill: 'black',
	align: 'center'
});
functionsButton.add(functionsButtonText);
menuButtonLayer.draw();

/* add functions to menu */
var menuFunctions = [];
for (var i = 0; i < funNames.length; i++) {
	menuFunctions[i] = makeFunctionGroup(funNames[i], menuFunctsXStart, menuYspacing);
	menuLayer.add(menuFunctions[i]);
}

/* add values to menu */
var menuValues = [];
for (var i = 0; i < valNames.length; i++) {
	menuValues[i] = makeValueGroup(valNames[i], menuValuesXStart, menuYspacing);
	menuLayer.add(menuValues[i]);
}

/* create the toolbox pallette in the workspace */
//var setupToolbox = function() {

	/*var toolboxWidth = width / 18; // 50
	var toolboxHeight = width / 5; // 180
	var toolboxXShift = toolboxWidth / 5; // 10
	var toolboxButtonSize = toolboxHeight / 6; // 30*/

	// add the entire group
	var toolboxGroup = new Kinetic.Group({
		x: width * .9,
		y: height * .2,
		draggable: false,
	});
	toolboxLayer.add(toolboxGroup);

	// add the box to contain the entire group
	var toolboxRect = new Kinetic.Rect({
		x:0,
		y:0,
		width: toolboxWidth,
		height: toolboxHeight - toolboxShift,
		fill: 'white',
		stroke: 'black',
		strokeWidth: .5,
	//lineJoin: 'round',
	shadowColor: 'black',
	shadowBlur: 0,
	shadowOffsetX: -1,
	shadowOffsetY: 1,
	shadowOpacity: .5
});
	toolboxGroup.add(toolboxRect);

	// add the mini bos above the main box for dragging
	var toolboxControl = new Kinetic.Rect({
		x:0,
		y:-toolboxShift,
		width: toolboxWidth,
		height: toolboxShift,
		name: 'toolControl',
		fill: 'grey',
		stroke: 'black',
		strokeWidth: .5,
	//lineJoin: 'round',
	shadowColor: 'black',
	shadowBlur: 0,
	shadowOffsetX: -1,
	shadowOffsetY: 1,
	shadowOpacity: .5
});
	toolboxGroup.add(toolboxControl);

	//add the work tool
	var workToolGroup = new Kinetic.Group({
		x: toolboxShift,
		y: toolboxShift,
		name: 'workTool'
	});
	toolboxGroup.add(workToolGroup);

	var workToolButton = new Kinetic.Rect({
		x: 0,
		y: 0,
		width: toolboxButtonSize,
		height: toolboxButtonSize,
		name: 'draw',
		fill: 'white',
		stroke: 'black',
		strokeWidth: .3,
		lineJoin: 'round',
		shadowColor: 'black',
		shadowOffsetX: -2,
		shadowOffsetY: 2,
		shadowOpacity: .5,
		shadowEnabled: false,
		working: false
	});
	workToolGroup.add(workToolButton);

	var workToolSymbol = new Kinetic.Shape({
		sceneFunc: function(context) {
			context.beginPath();
			context.moveTo(0, 0);
			context.lineTo(5, 12);
			context.lineTo(1, 12);
			context.lineTo(1, 18);
			context.lineTo(-1, 18);
			context.lineTo(-1, 12);
			context.lineTo(-5, 12);
			context.closePath();
			context.fillStrokeShape(this);
		},
		x: toolboxButtonSize / 3.3,
		y: toolboxButtonSize / 4.5,
		fill: 'black',
		stroke: 'black',
		strokeWidth: .5,
		lineJoin: 'round',
		rotation: -30,
	});
	workToolGroup.add(workToolSymbol);

	/* Transparent box that covers the button to ensure its function when clicked on */
	var workToolCover = new Kinetic.Rect({
		x: 0,
		y: 0,
		width: toolboxButtonSize,
		height: toolboxButtonSize
	});
	workToolGroup.add(workToolCover);

	// add the draw line tool group
	var lineToolGroup = new Kinetic.Group({
		x: toolboxShift,
		y: (toolboxShift * 2) + toolboxButtonSize,
		name: 'lineTool'
	});
	toolboxGroup.add(lineToolGroup);

	// add the draw line tool button
	var lineToolButton = new Kinetic.Rect({
		x: 0,
		y: 0,
		width: toolboxButtonSize,
		height: toolboxButtonSize,
		name: 'draw',
		fill: 'white',
		stroke: 'black',
		strokeWidth: .3,
		lineJoin: 'round',
		shadowColor: 'black',
		shadowOffsetX: -2,
		shadowOffsetY: 2,
		shadowOpacity: .5,
		shadowEnabled: false,
		working: false
	});
	lineToolGroup.add(lineToolButton);

	// add the draw line symbol on the button
	var lineToolLine = new Kinetic.Line({
		points: [(toolboxButtonSize * (7/30)), (toolboxButtonSize * (7/30)), (toolboxButtonSize * (24/30)), (toolboxButtonSize * 24/30)],
		stroke: 'black',
		strokeWidth: 2,
		lineCap: 'round'
	});
	lineToolGroup.add(lineToolLine);

	/* Transparent box that covers the button to ensure its function when clicked on */
	var lineToolCover = new Kinetic.Rect({
		x: 0,
		y: 0,
		width: toolboxButtonSize,
		height: toolboxButtonSize
	});
	lineToolGroup.add(lineToolCover);

	// add the delete tool group
	var deleteToolGroup = new Kinetic.Group({
		x: toolboxShift,
		y: (toolboxShift * 3) + (toolboxButtonSize * 2),
		name: 'deleteTool'
	});
	toolboxGroup.add(deleteToolGroup);

	// add the delete line tool button
	var deleteToolButton = new Kinetic.Rect({
		x: 0,
		y: 0,
		width: toolboxButtonSize,
		height: toolboxButtonSize,
		name: 'delete',
		fill: '#D93F3F',
		stroke: 'black',
		strokeWidth: .3,
		lineJoin: 'round',
		shadowColor: 'black',
		shadowOffsetX: -2,
		shadowOffsetY: 2,
		shadowOpacity: .5,
		shadowEnabled: false,
		working: false
	});
	deleteToolGroup.add(deleteToolButton);

	// add the delete symbol on the button
	var deleteToolSym1 = new Kinetic.Rect({
		x: toolboxButtonSize * (7/30),
		y: toolboxButtonSize * (7/30),
		width: 0,
		height: .8 * toolboxButtonSize,
		stroke: 'black',
		fill: 'black',
		rotation: -45, 
		strokeWidth: 3
		//lineCap: 'round'
	});
	deleteToolGroup.add(deleteToolSym1);

	var deleteToolSym2 = new Kinetic.Rect({
		x: toolboxButtonSize * (24/30),
		y: toolboxButtonSize * (7/30),
		width: 0,
		height: .8 * toolboxButtonSize,
		strokeWidth: 3,
		stroke: 'black',
		fill: 'black',
		//scaleX: - 1,
		rotation: 45
	});
	deleteToolGroup.add(deleteToolSym2);

	/* Transparent box that covers the button to ensure its function when clicked on */
	var deleteToolCover = new Kinetic.Rect({
		x: 0,
		y: 0,
		width: toolboxButtonSize,
		height: toolboxButtonSize
	});
	deleteToolGroup.add(deleteToolCover);

	// add the undo tool button
	var undoButton = new Kinetic.Shape({
		sceneFunc: function(context) {
			context.beginPath();
			context.moveTo(0, 0);
			context.lineTo(35, 30);
			context.lineTo(35, 12);
			context.bezierCurveTo(60, 5, 100, 15, 80, 70);
			context.bezierCurveTo(110, 10, 80, -12, 35, -12);
			context.lineTo(35, -30);            
			context.closePath();
			context.fillStrokeShape(this);
		},
		x: toolboxShift -3,
		y: (toolboxShift*5) + (toolboxButtonSize * 3) + 15,
		name: 'undo',
		scaleX: .35,
		scaleY: .35,
		fill: '#B3B1B1',
		stroke: 'black',
		strokeWidth: 1,
		lineJoin: 'round',
		rotation: -40,
		shadowColor: 'black',
		shadowOffsetX: -2,
		shadowOffsetY: 2,
		shadowOpacity: .5,
		shadowEnabled: false
	});
	toolboxGroup.add(undoButton);

	var redoButton = new Kinetic.Shape({
		sceneFunc: function(context) {
			context.beginPath();
			context.moveTo(0, 0);
			context.lineTo(35, 30);
			context.lineTo(35, 12);
			context.bezierCurveTo(60, 5, 100, 15, 80, 70);
			context.bezierCurveTo(110, 10, 80, -12, 35, -12);
			context.lineTo(35, -30);            
			context.closePath();
			context.fillStrokeShape(this);
		},
		x: toolboxShift + toolboxButtonSize + 3,
		y: (toolboxShift*5) + (toolboxButtonSize * 4) + 20,
		name: 'redo',
		scaleX: -.35,
		scaleY: .35,
		fill: '#B3B1B1',
		stroke: 'black',
		strokeWidth: 1,
		lineJoin: 'round',
		rotation: 40,
		shadowColor: 'black',
		shadowOffsetX: -2,
		shadowOffsetY: 2,
		shadowOpacity: .5,
		shadowEnabled: false
	});
	toolboxGroup.add(redoButton);

	toolboxLayer.draw();

	stage.draw();
/*
toolboxGroup.on ('mouseover', function(evt) {
	var button = evt.target;
	if (isDrawTool(button) || isDeleteTool(button) || isRedoTool(button) || isUndoTool(button)) {
		button.setAttrs('shadowEnabled', true);
	} else if (isToolControl(button)) {
		toolboxGroup.setAttr('draggable', true);
	}
	toolboxLayer.draw();
});

toolboxGroup.on ('mouseout', function(evt) {
	var button = evt.target;
	if (isDrawTool(button) || isDeleteTool(button) || isRedoTool(button) || isUndoTool(button)) {
		button.setAttrs('shadowEnabled', false);
	} else if (isToolControl(button)) {
		toolboxGroup.setAttr('draggable', false);
	}
	toolboxLayer.draw();
});

toolboxGroup.on('click', function(evt) {
	var button = evt.target;
	//console.log (button.attrs.working);
	if (isDrawTool(button)) {
		shadeButton(button);
		unshadeOthers(button);
	} else if (isDeleteTool(button)) {

	} else if (isRedoTool(button)) {

	} else if (isUndoTool(button)) {

	}
	toolboxLayer.draw();
});
*/


//MENU ANIMATIONS

var valueExpanded = false;
var functionExpanded = false;

/*
On click of value menu button:
1. Neither values or functions are expanded.
	- move functionsButton right.
	- expand values
2. Values are not expanded, functions are expanded.
	- collapse functions to the right and move functionsButon
	- expand values
3. Values are expanded, functions are not.
	- collapse values
	- move functionsButton left. 
	*/
	valuesButton.on('click', function(){
		if (!valueExpanded) {
			if (!functionExpanded) {
				moveFunctionsButtonRight();
				moveFunctionNodesRight();
				expandValueNodes();

				valueExpanded = true;
			} // if functions are also not expanded
			else {
				moveFunctionsButtonRight();
				moveFunctionNodesRight();
				expandValueNodes();
				
				valueExpanded = true;
				functionExpanded = false;
			} // else functions were already expanded
		} // if values are not expanded
		else {
			moveValueNodesIn();
			moveFunctionNodesIn();	
			moveFunctionsButtonLeft();

			valueExpanded = false;
		} // else values were already expanded
	});
/*
On click of function menu button:
1. Neither functions or values are expanded.
	- expand functions
2. Functions are not expanded, values are expanded.
	- collapse values
	- move functionsButton left
	- expand functions
3. Functions are expanded, values are not.
	- collapse functions 
	*/
	functionsButton.on('click', function(){
		if (!functionExpanded) {
			if (!valueExpanded) {
				expandFunctionNodes();

				functionExpanded = true;
			} // functions and values not expanded
			else {
				moveValueNodesIn();
				moveFunctionsButtonLeft();
				expandFunctionNodes();

				functionExpanded = true;
				valueExpanded = false;
			} // functions not expanded, values expanded
		}
		else {
			moveFunctionNodesIn();
			
			functionExpanded = false;
		} // functions are expanded
	});

// ADDING TO WORKSPACE

/* variables to globally reference the most recently used object/line and current state */
var currShape;
var currLine;
var makingLine = false;
var animation = false;
var lineToolOn = false;
var workToolOn = false;
var deleteToolOn = false;

/*
	On mousedown of a menu object (value or function prototype), you create a copy of that object and begin to draw it.
	*/
	menuLayer.on('mousedown', function(evt) {
		if (!makingLine) {
			var group = evt.target.getParent();
			if (isFunction(group)) {
				var newGroup = makeFunctionGroup(group.attrs.name, group.attrs.x, group.attrs.y);
			} else {
				var newGroup = makeValueGroup(group.attrs.name, group.attrs.x, group.attrs.y);
	} // if function / else value
	newGroup.setAttr('visible', true);
	dragLayer.add(newGroup);
	newGroup.startDrag();
	dragLayer.draw();
}
});

/*
	when an object being dragged is released:
	1. check that it isnt in the menu area
	--if it is a new object, add the appropriate number of outlets to it
	2. if its in the menu area destroy it and all lines attached to it
	*/
	dragLayer.on('mouseup', function(evt) {
		var group = evt.target.getParent();
		if (group.attrs.y > menuHeight) {
			group.moveTo(workLayer);
			if (isFunction(group) && group.children.length < 4) {
				for (var i = 0; i < functions[group.attrs.name].min; i++) {
					addOutlet(group);
			} // add outlets to a new node
		} // if new function 
		else if (isValue(group)) {
			group.children[2].setAttr('visible', true);
		}
		if (group.children[2].attrs.expanded) {
			renderCanvas(group);
			} // if 
		} else {
		// deal with lines coming in to the node being deleted
		var targetLine;
		for(var i = 3; i < group.children.length; i++) {
			targetLine = group.children[i].attrs.lineIn;
			if(targetLine != null) {
				targetLine.attrs.outlet = null;
				targetLine.attrs.source.attrs.lineOut.splice(targetLine.attrs.sourceIndex, 1);
				targetLine.destroy();
			}
		}
		// deal with the lines leading out of the node being deleted
		var outletParent;
		for(var i = 0; i < group.attrs.lineOut.length; i++) {
			targetLine = group.attrs.lineOut[i];
			if (targetLine.attrs.outlet != null) {
				outletParent = targetLine.attrs.outlet.getParent();
				outletParent.attrs.numInputs--;
				targetLine.attrs.outlet.attrs.lineIn = null;
				assertRenderable(outletParent);
				updateForward(outletParent);
			}
			targetLine.destroy();
		}
		lineLayer.draw();
		group.destroy();
	}
	menuLayer.draw();
	menuButtonLayer.draw();
	dragLayer.draw();
	workLayer.draw();
});

/*
	When you click down on an object in the workLayer and arent in the process of making
	a line, move that object to the dragLayer and allow it to be dragged.
	*/
	workLayer.on('mousedown', function(evt) {
		if (!makingLine && !isImageBox(evt.target)) {
			var group = evt.target.getParent();
			group.moveTo(dragLayer);
			currShape = group;
			group.startDrag();
			workLayer.draw();
			dragLayer.draw();
			if (group.attrs.renderLayer != null) {
				group.attrs.renderLayer.draw();
			}
		}
	});

/*
	while you are drawing a line, make it move with the cursor.
		*/
	stage.addEventListener('contentMousemove', function(){
		if(makingLine) {
			currLine.points()[2] = stage.getPointerPosition().x;
			currLine.points()[3] = stage.getPointerPosition().y;
			lineLayer.draw();
		}
	});

/*
	while making a line, make outlets grow when they are moused over to signify that they
	are valid connections
*/
workLayer.on('mouseover', function(evt) {
	var shape = evt.target;
	if (makingLine) {
		if (isOutlet(shape)) {
			shape.scale({
				x: 1.5,
				y: 1.5
			});
			workLayer.draw();
		} // if outlet
	} // if makingLine
	else if (isImageBox(shape) && shape.attrs.expanded) {
		animation = true;
		var frame = function() {
			renderCanvas(shape.getParent());
			if (animation) {
				setTimeout(frame, 50);
			}
		}
		frame();
	} // else if expanded image box
});

/*
	when the cursor is moved out of an outlet while drawing a line, return it to its
	original size
	*/
	workLayer.on('mouseout', function(evt) {
		var shape = evt.target;
		if (makingLine) {
			if (isOutlet(shape)) {
				shape.scale({
					x: 1,
					y: 1
				});
				workLayer.draw();
		} // if outlet
	} // if makingLine
	else if (isImageBox(shape) && shape.attrs.expanded) {
		animation = false;
	} // else if expanded image box
});

/*
There are 3 different modes:
	1. WorkTool (users can navigate the menu, drag objects onto the board from the menu, drag
			objects around in the work layer, or render thumbnails)
	2. LineTool (users can connect different nodes by clicking on one, and connecting to an outlet
			on another)
	3. DeleteTool (users can remove unwanted functions, values, or lines from the workLayer)

	The default is workTool. 

	When making a line, form a connection on click if the click was on an outlet.
	Behind the scenes:
	1. if the object clicked was the source of the line, destroy the line.
	2. If the outlet already had a connection, make that connection null and destroy it
	--otherwise, this is connected to a new outlet so increment numInputs for the group
	3. set connections within the line and its outlet, so line has a reference to the 
	outlet, and the outlet has a reference to the line
	--make the line stick to the outlet
	--set makingLine = false
	--shrink the outlet back to its original size
	--check if we have enough outlets to show the render box
	4. if we have all visible outlets filled but the function can take more inputs, add
	an outlet.
	5. otherwise keep drawing the line.
	*/


	workLayer.on('click', function(evt) {
		var shape = evt.target;
		var parent = shape.getParent();
		if (workToolOn) {

			if (isImageBox(shape)) {
				if (!shape.attrs.expanded) {
					renderCanvas(parent);
					shape.attrs.expanded = true;
				} else {
					shape.attrs.expanded = false;
					animation = false;
					var collapseCanvas = function(){
						parent.attrs.renderLayer.destroy();
						parent.attrs.renderLayer = null;
						parent.children[2].setAttrs({
							width: imageBoxSideLength,
							height: imageBoxSideLength
						});	
					}
					setTimeout(collapseCanvas, 50);
				}
				setTimeout(function() {workLayer.draw()}, 50);
			}
		} else if (lineToolOn) {
			if (makingLine) {
				if (parent == currLine.attrs.source || isCycle(currLine.attrs.source, parent)) {
					currLine.attrs.source.attrs.lineOut.splice([currLine.attrs.source.attrs.lineOut.length - 1], 1);
					currLine.destroy();
					if (isOutlet(shape)) {
						shape.scale({	x: 1, y: 1 });
					}
					makingLine = false;
				} else if (isOutlet(shape)) {
			//check if outlet already has an input
			if (shape.attrs.lineIn != null) {
				//POSSIBLE NEED TO DESTROY LINE ITSELF
				var source = shape.attrs.lineIn.attrs.source;
				source.attrs.lineOut[shape.attrs.lineIn.attrs.sourceIndex].destroy();
				source.attrs.lineOut.splice([shape.attrs.lineIn.attrs.sourceIndex], 1);
			} else {
				parent.attrs.numInputs++;
			} // check if theres already a line going in to the outlet
			shape.attrs.lineIn = currLine;
			currLine.points()[2] = parent.x();
			currLine.points()[3] = parent.y() + shape.y();
			currLine.attrs.outlet = shape;
			makingLine = false;
			shape.scale({	x: 1, y: 1 });
			assertRenderable(parent);
			if (parent.attrs.numInputs == parent.children.length - 3 &&
				parent.attrs.numInputs < parent.attrs.maxInputs) {
				addOutlet(parent);
		}
		updateForward(parent);
		} // if clicked on self, else clicked on a valid outlet
	} else {
		makingLine = true;
		var group = evt.target.getParent();
		currLine = makeLine(group);
		group.attrs.lineOut[group.attrs.lineOut.length] = currLine;
		lineLayer.add(currLine);
	}
} else if (deleteToolOn) {
	if(isFunction(parent) || isValue(parent)) {
		// deal with lines coming in to the node being deleted
		var group = parent;
		var targetLine;
		for(var i = 3; i < group.children.length; i++) {
			targetLine = group.children[i].attrs.lineIn;
			if(targetLine != null) {
				targetLine.attrs.outlet = null;
				targetLine.attrs.source.attrs.lineOut.splice(targetLine.attrs.sourceIndex, 1);
				targetLine.destroy();
			}
		}
		// deal with the lines leading out of the node being deleted
		var outletParent;
		for(var i = 0; i < group.attrs.lineOut.length; i++) {
			targetLine = group.attrs.lineOut[i];
			if (targetLine.attrs.outlet != null) {
				outletParent = targetLine.attrs.outlet.getParent();
				outletParent.attrs.numInputs--;
				targetLine.attrs.outlet.attrs.lineIn = null;
				assertRenderable(outletParent);
				updateForward(outletParent);
			}
			targetLine.destroy();
		}
		group.destroy();
	} else if (isLine(shape)) {
		shape.attrs.source.attrs.lineOut.splice(shape.attrs.sourceIndex, 1);
		shape.attrs.outlet.attrs.lineIn = null;
		shape.destroy();
	} 
}

workLayer.draw();
lineLayer.draw();
});

/*
	While an object is being dragged, move all lines connected to it with it.
	*/
	dragLayer.on('draw', function() {
		if(currShape != null) {
			var targetLine;
			for(var i = 0; i < currShape.children.length - 3; i++) {
				targetLine = currShape.children[i+3].attrs.lineIn;
				if(targetLine != null) {
					targetLine.points()[2] = currShape.x();
					targetLine.points()[3] = currShape.y() + currShape.children[i+3].y();
				}
			}
			for(var i = 0; i < currShape.attrs.lineOut.length; i++) {
				targetLine = currShape.attrs.lineOut[i];
				targetLine.points()[0] = currShape.x() + functionRectSideLength - 3;
				targetLine.points()[1] = currShape.y() + functionTotalSideLength / 2;
			}
			lineLayer.draw();
		}
	});

	var enableWorkTool = function() {
		workToolGroup.children[0].setAttr('shadowEnabled', true);
		workToolOn = true;
		disableTool(lineToolGroup);
		disableTool(deleteToolGroup);
		toolboxLayer.draw();
	}

	/* Toolbox controls */
	workToolGroup.on('click', function(){
		if (!workToolOn) {
			enableWorkTool();
		}		
	});


	lineToolGroup.on('click', function() {
		if (lineToolOn) {
			enableWorkTool();
		} else {
			lineToolGroup.children[0].setAttr('shadowEnabled', true);
			lineToolOn = true;
			disableTool(workToolGroup);
			disableTool(deleteToolGroup);
			toolboxLayer.draw();
		}
	});

	deleteToolGroup.on('click', function() {
		if (deleteToolOn) {
			enableWorkTool();
		} else {
			deleteToolGroup.children[0].setAttr('shadowEnabled', true);
			deleteToolOn = true;
			disableTool(workToolGroup);
			disableTool(lineToolGroup);
			toolboxLayer.draw();
		}
	});


	</script>
</body>
<html>