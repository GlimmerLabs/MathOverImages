<!DOCTYPE HTML>
<html>
<head>
	<script>
	var width = 900;
	var height = 2 * width / 3;

	var funNames = ['add', 'multiply', 'negate', 'sine', 'cosine', 'absolute', 'average', 'sign', 'rgb'];
	var functions = {
		add: 			{rep: '+', 	 max: 20, min: 2, index: 0},
		multiply: {rep: '*', 	 max: 20, min: 2, index: 1},
		negate: 	{rep: '-', 	 max: 1,  min: 1, index: 2},
		sine: 		{rep: 'sin', max: 1,  min: 1, index: 3},
		cosine: 	{rep: 'cos', max: 1,  min: 1, index: 4},
		absolute: {rep: 'abs', max: 1,  min: 1, index: 5},
		average: 	{rep: 'ave', max: 20, min: 2, index: 6},
		sign: 		{rep: 'sign',max: 1,  min: 1, index: 7},
		wrap: 		{rep: 'wrap',max: 1,  min: 1, index: 8},
		rgb: 			{rep: 'rgb', max: 3,  min: 3, index: 9}
	}

	var valNames = ['x', 'y', 'second', 'minute', 'hour', 'day', 'constant'];
	var values = {
		x: 				{rep: 'x', 	 max: 20, min: 2, color: 'gray', 	index: 0},
		y: 				{rep: 'y', 	 max: 20, min: 2, color: 'gray', 	index: 1},
		second: 	{rep: 't.s', max: 1,  min: 1, color: 'gold', 	index: 2},
		minute:		{rep: 't.m', max: 1,  min: 1, color: 'gold', 	index: 3},
		hour: 		{rep: 't.h', max: 1,  min: 1,	color: 'gold', 	index: 4},
		day: 			{rep: 't.d', max: 1,  min: 1, color: 'gold', 	index: 5},
		constant:	{rep: '', 	 max: 20, min: 2, color: 'purple',index: 6},
	}
	</script>
	<script>
	/*Global variables for size and colors*/
	var functionStrokeWidth = width / 90;
	var functionHalfStrokeWidth = functionStrokeWidth / 2;
	var functionTotalSideLength = width / 20;
	var functionRectSideLength = functionTotalSideLength - functionStrokeWidth;
	var functionColor = '#508C37';

	var valueSideLength = functionTotalSideLength / 1.414;
	var valueXYColor = 'gray'
	var valueTimeColor = 'gold'
	var valueConstantColor = 'purple'

	var imageBoxSideLength = width / 80;
	var imageBoxColor = 'white'
	var functionImageBoxOffset = width / 300;
	var valueImageBoxOffset = width / 30;

	var outletXOffset = width / 255;
	var outletYOffset = functionRectSideLength / 3;
	var outletColor =  '#FFC440';

	var lineStrokeWidth = 2;

	var menuHeight = width / 9; 
	var menuCornerWidth = width / 5;
	var valMenuXSpacing = width / 32;
	var functMenuXSpacing = width / 68;
	var menuYspacing = width * 11/360;
	var buttonWidth = width / 10;
	var menuFunctsXStart = 2 * (buttonWidth - functionRectSideLength) + menuCornerWidth- functionTotalSideLength / 2;
	var menuFunctsXEnd = width - buttonWidth + functionRectSideLength / 2;
	var menuValuesXStart = menuCornerWidth + buttonWidth / 2;
	var menuAnimDuration = 1;

	</script>

	<style>
	body {
		margin: 0px;
		padding: 0px;
	} 
	#container {
		background-color: rgb(241, 248, 255);
		width: 900px;
		height: 600px;
	}
	</style>
</head>
<body>
	<div id="container"></div>
	<script src="http://d3lp1msu2r81bx.cloudfront.net/kjs/js/lib/kinetic-v5.1.0.min.js">
	</script>
	<script defer="defer">

	var stage = new Kinetic.Stage({
		container: 'container',
		width: width,
		height: height
	});


	// LAYERS
	var borderLayer = new Kinetic.Layer();
	var lineLayer = new Kinetic.Layer();
	var menuLayer = new Kinetic.Layer();
	var menuButtonLayer = new Kinetic.Layer();
	var workLayer = new Kinetic.Layer();
	var dragLayer = new Kinetic.Layer();

	stage.add(lineLayer);
	stage.add(menuLayer);
	stage.add(menuButtonLayer);
	stage.add(workLayer);
	stage.add(borderLayer);
	stage.add(dragLayer);



	// CONSTRUCTORS

/*
	Function nodes and Value nodes are groups of objects. Members of groups can
	be accessed through the array 'group'.children[].
	Children are stored in the following order:
	0. Underlying Shape
	1. Text
	2+. Outlet nodes (only for functions)
	TODO: add render boxes in bottom-righthand corner, before Outlets
	*/


/* 
	makeFunctionGroup takes a string funName, a key in the functions object above,
	an integer x, and an integer y, and returns the corresponding function node object,
	with top right corner at the given x,y coordinate.
	*/
	var makeFunctionGroup = function(funName, x, y) {
		var newGroup = new Kinetic.Group({
			name: funName,
			x: x - functionHalfStrokeWidth,
			y: y,
			numInputs: 0,
			maxInputs: functions[funName].max,
			lineOut: [],
			funct: null,
			index: functions[funName].index,
			visible: false
		});

		var newRect = new Kinetic.Rect({
			name: funName,
			x: functionHalfStrokeWidth,
			y: functionHalfStrokeWidth,
			width: functionRectSideLength,
			height: functionRectSideLength,
			fill: functionColor,
			lineJoin: 'round',
			stroke: functionColor,
			strokeWidth: functionStrokeWidth
		});
		newGroup.add(newRect);

		var newText = new Kinetic.Text({
			text: functions[funName].rep,
			fontFamily: 'Open Sans',
			fill: 'black',
			fontSize: 16,
			x: 0,
			y: functionTotalSideLength/2 - functionHalfStrokeWidth,
			width: functionTotalSideLength,
			align: 'center'
		});
		newGroup.add(newText);

		var newBox = new Kinetic.Rect({
			x: functionRectSideLength + functionImageBoxOffset,
			y: functionRectSideLength + functionImageBoxOffset,
			width: imageBoxSideLength,
			height: imageBoxSideLength,
			fill: imageBoxColor,
			stroke: 'black',
			strokeWidth: .5,
			visible: false
		});
		newGroup.add(newBox);

		return newGroup;
	};


/*
	makeValueGroup takes a string valName, the name of a key in the values object above,
	an integer x, and an integer y, and returns the corresponding function node object,
	centered at (x + width / 40, y + width / 40).
	*/
	var makeValueGroup = function(valName, x, y) {
		var newGroup = new Kinetic.Group({
			name: valName,
			x: x,
			y: y,
			lineOut: [],
			index: values[valName].index,
			visible: false
		});

		var newRect = new Kinetic.Rect({
			x: functionRectSideLength/2,
			y: 0,
			width: valueSideLength,
			height: valueSideLength,
			fill: values[valName].color,
			rotation: 45,
			name: valName
		});
		newGroup.add(newRect);

		var newText = new Kinetic.Text({
			text: values[valName].rep,
			fontFamily: 'OpenSans',
			fill: 'black',
			fontSize: 16,
			x: 0,
			y: valueSideLength/2,
			width: functionRectSideLength,
			align: 'center'
		});
		newGroup.add(newText);

		var newBox = new Kinetic.Rect({
			x: valueImageBoxOffset,
			y: valueImageBoxOffset,
			width: imageBoxSideLength,
			height: imageBoxSideLength,
			fill: imageBoxColor,
			stroke: 'black',
			strokeWidth: .5,
			visible: false
		});
		newGroup.add(newBox);
		return newGroup;
	};

/*
	makeOutlet takes a function node object, functGroup, and returns an outlet node object 
	to be added to that group.
	It DOES NOT add the outlet to the group.
	*/
	var makeOutlet = function(functGroup) {
		var bezPoint = width / 50;
		var outlet = new Kinetic.Shape({
			sceneFunc: function(context) {
				context.beginPath();
				context.moveTo(0, 0);
				context.bezierCurveTo(-bezPoint, -bezPoint, -bezPoint, bezPoint, 0, 0);
				context.closePath();
				context.fillStrokeShape(this);
			},
			name: 'outlet' + (functGroup.children.length - 3),
			x:functGroup.children[0].x() + outletXOffset,
			y:functGroup.children[0].y() + (functGroup.children.length - 3) * outletYOffset + functionHalfStrokeWidth,
			fill: '#FFC440',
			stroke: 'black',
			strokeWidth: 1,
			lineIn: null
		});
		return outlet;
	};

	var makeLine = function(source) {
		var newLine = new Kinetic.Line({
			points: [
			source.x() + functionRectSideLength - 3,
			source.y() + functionTotalSideLength / 2,
			source.x() + width / 20,
			source.y() + width / 40,
			],
			stroke: 'black',
			strokeWidth: lineStrokeWidth,
			source: source,
			sourceIndex: source.attrs.lineOut.length,
			outlet: null
		});
		source.attrs.lineOut[source.attrs.lineOut.length] = newLine;
		return newLine;
	}

	var makeMenuTween = function(target, xEnd, visibility) {
		return new Kinetic.Tween({
			node: target,
			duration: menuAnimDuration,
			x: xEnd,
			visible: visibility,
			easing: Kinetic.Easings.StrongEaseOut
		});
	};

//METHODS
/*
	addOutlet takes a function group funGroup and adds an outlet to it, expanding the node if there is not enough space for the outlet.
	*/
	var addOutlet = function(funGroup) {
		if(funGroup.children.length - 3 < funGroup.attrs.maxInputs) {
			if(funGroup.children.length - 3 > 2) {
				funGroup.children[0].setAttr('height',
					funGroup.children[0].attrs.height + outletYOffset);
				funGroup.children[1].setAttr('y', funGroup.children[1].attrs.y + outletYOffset / 2);

			}
			var newOutlet = makeOutlet(funGroup);
			funGroup.add(newOutlet);
			stage.draw();
		}
	};


	// Create functions to Move Menu Items
	var moveValueNodesIn = function() {
		for (var i = 0; i < menuValues.length; i++) {
			var moveValue = makeMenuTween(menuValues[i], menuValuesXStart, false);
			moveValue.play();
		}
	};

	var expandValueNodes = function() {
		for (var i = 0; i < menuValues.length; i++) {
			var moveValue = makeMenuTween(menuValues[i], menuCornerWidth + buttonWidth + valMenuXSpacing + i * (valMenuXSpacing + functionTotalSideLength), true);
			moveValue.play();
		}
	};

	var moveFunctionNodesIn = function() {
		for (var i = 0; i < menuFunctions.length; i++) {
			var moveFunction = makeMenuTween(menuFunctions[i], menuFunctsXStart, false);
			moveFunction.play();
		}
	};

	var moveFunctionNodesRight = function() {
		for (var i = 0; i < menuFunctions.length; i++) {
			var moveFunction = makeMenuTween(menuFunctions[i], menuFunctsXEnd, false);
			moveFunction.play();
		}
	};

	var expandFunctionNodes = function() {
		for (var i = 0; i < menuFunctions.length; i++) {
			var moveFunction = makeMenuTween(menuFunctions[i], menuCornerWidth + 2 * buttonWidth + functMenuXSpacing + i * (functMenuXSpacing + functionTotalSideLength), true)
			moveFunction.play();
		}
	}

	var moveFunctionsButtonRight = function() {
		var moveButton = makeMenuTween(functionsButton, width - buttonWidth, true)
		moveButton.play();
	};

	var moveFunctionsButtonLeft = function() {
		var moveButton = makeMenuTween(functionsButton, menuCornerWidth + buttonWidth, true)
		moveButton.play();
	};

//SETUP STAGE

/* create and add menu border */
var borderLine = new Kinetic.Line({
	points: [0, menuHeight, width, menuHeight],
	stroke: 'black',
	strokeWidth: 2
});

borderLayer.add(borderLine);
borderLayer.draw();

/* create and add sliding menu buttons */
var valuesButton = new Kinetic.Group({
	x: menuCornerWidth
});
menuButtonLayer.add(valuesButton);

var valuesButtonBox = new Kinetic.Rect({
	x:0,
	y:0,
	width: buttonWidth,
	height: menuHeight,
	fill: 'lavender',
	stroke: 'black',
	strokeWidth: 2
});
valuesButton.add(valuesButtonBox);

var valuesButtonRect = new Kinetic.Rect({
	x: buttonWidth / 2,
	y: menuHeight / 4,
	width: valueSideLength,
	height: valueSideLength,
	fill: 'purple',
	rotation: 45,
});
valuesButton.add(valuesButtonRect);

var valuesButtonText = new Kinetic.Text({
	text: 'add a value',
	x: 0,
	y: menuHeight / 2 + menuHeight / 4,
	width: buttonWidth,
	height: menuHeight / 4,
	fill: 'black',
	align: 'center'
});
valuesButton.add(valuesButtonText);

var functionsButton = new Kinetic.Group({
	x: menuCornerWidth + buttonWidth
});
menuButtonLayer.add(functionsButton);

var functionsButtonBox = new Kinetic.Rect({
	x:0,
	y:0,
	width: buttonWidth,
	height: menuHeight,
	fill: '#D7EBCF',
	stroke: 'black',
	strokeWidth: 2
});
functionsButton.add(functionsButtonBox);

var functionsButtonRect = new Kinetic.Rect({
	x: buttonWidth / 2 - functionRectSideLength / 2,
	y: menuHeight / 4,
	width: functionRectSideLength,
	height: functionRectSideLength,
	fill: functionColor,
	lineJoin: 'round',
	stroke: functionColor,
	strokeWidth: functionStrokeWidth
});
functionsButton.add(functionsButtonRect);

var functionsButtonText = new Kinetic.Text({
	text: 'add a function',
	x: 0,
	y: menuHeight / 2 + menuHeight / 4,
	width: buttonWidth,
	height: menuHeight / 4,
	fill: 'black',
	align: 'center'
});
functionsButton.add(functionsButtonText);
menuButtonLayer.draw();

/* add functions to menu */
var menuFunctions = [];
for (var i = 0; i < funNames.length; i++) {
	menuFunctions[i] = makeFunctionGroup(funNames[i], menuFunctsXStart, menuYspacing);
	menuLayer.add(menuFunctions[i]);
}

/* add values to menu */
var menuValues = [];
for (var i = 0; i < valNames.length; i++) {
	menuValues[i] = makeValueGroup(valNames[i], menuValuesXStart, menuYspacing);
	menuLayer.add(menuValues[i]);
}

stage.draw();

//MENU ANIMATIONS

var valueExpanded = false;
var functionExpanded = false;

/*
1. Neither values or functions are expanded.
	- move functionsButton right.
	- expand values
2. Values are not expanded, functions are expanded.
	- collapse functions to the right and move functionsButon
	- expand values
3. Values are expanded, functions are not.
	- collapse values
	- move functionsButton left. 
	*/
	valuesButton.on('click', function(){
		if (!valueExpanded) {
			if (!functionExpanded) {
				moveFunctionsButtonRight();
				moveFunctionNodesRight();
				expandValueNodes();

				valueExpanded = true;
			} // if functions are also not expanded
			else {
				moveFunctionsButtonRight();
				moveFunctionNodesRight();
				expandValueNodes();
				
				valueExpanded = true;
				functionExpanded = false;
			} // else functions were already expanded
		} // if values are not expanded
		else {
			moveValueNodesIn();
			moveFunctionNodesIn();	
			moveFunctionsButtonLeft();

			valueExpanded = false;
		} // else values were already expanded
	});
/*
1. Neither functions or values are expanded.
	- expand functions
2. Functions are not expanded, values are expanded.
	- collapse values
	- move functionsButton left
	- expand functions
3. Functions are expanded, values are not.
	- collapse functions 
	*/
	functionsButton.on('click', function(){
		if (!functionExpanded) {
			if (!valueExpanded) {
				expandFunctionNodes();

				functionExpanded = true;
			} // functions and values not expanded
			else {
				moveValueNodesIn();
				moveFunctionsButtonLeft();
				expandFunctionNodes();

				functionExpanded = true;
				valueExpanded = false;
			} // functions not expanded, values expanded
		}
		else {
			moveFunctionNodesIn();
			
			functionExpanded = false;
		} // functions are expanded
	});

// ADDING TO WORKSPACE

var currShape;
var currLine;
var makingLine = false;

menuLayer.on('mousedown', function(evt) {
	if (!makingLine) {
		var group = evt.target.getParent();
		if (group.attrs.maxInputs != null) {
			var newGroup = makeFunctionGroup(group.attrs.name, group.attrs.x, group.attrs.y);
		} else {
			var newGroup = makeValueGroup(group.attrs.name, group.attrs.x, group.attrs.y);
	} // if function / else value
	newGroup.setAttr('visible', true);
	dragLayer.add(newGroup);
	newGroup.startDrag();
	dragLayer.draw();
}
});

dragLayer.on('mouseup', function(evt) {
	var group = evt.target.getParent();
	if (group.attrs.y > menuHeight) {
		group.moveTo(workLayer);
		if (group.attrs.maxInputs != null && group.children.length < 4) {
			for (var i = 0; i < functions[group.attrs.name].min; i++) {
				addOutlet(group);
			}
		} // for 	
	} else {
		group.destroy();
	}
	stage.draw();

});

workLayer.on('mousedown', function(evt) {
	if (!makingLine) {
		var group = evt.target.getParent();
		group.moveTo(dragLayer);
		currShape = group;
		group.startDrag();
		stage.draw();
	}
});



workLayer.on('dblclick', function(evt) {
	makingLine = true;
	var group = evt.target.getParent();
	currLine = makeLine(group);
	group.attrs.lineOut[group.attrs.lineOut.length] = currLine;
	lineLayer.add(currLine);
	lineLayer.draw();
});

stage.addEventListener('contentMousemove', function(){
	if(makingLine) {
		currLine.points()[2] = stage.getPointerPosition().x;
		currLine.points()[3] = stage.getPointerPosition().y;
		lineLayer.draw();
	}
});

workLayer.on('mouseover', function(evt) {
	if (makingLine) {
		var shape = evt.target;
		if ((shape.attrs.name != null) && shape.attrs.name.substring(0,6) == 'outlet') {
			shape.scale({
				x: 1.5,
				y: 1.5
			});
			workLayer.draw();
		} // if outlet
	} // if makingLine
});

workLayer.on('mouseout', function(evt) {
	if (makingLine) {
		var shape = evt.target;
		if ((shape.attrs.name != null) && shape.name().substring(0,6) == 'outlet') {
			shape.scale({
				x: 1,
				y: 1
			});
			workLayer.draw();
		} // if outlet
	} // if makingLine
});

workLayer.on('click', function(evt) {
	if (makingLine) {
		var shape = evt.target;
		var parent = shape.getParent();
		if ((shape.attrs.name != null) && shape.name().substring(0,6) == 'outlet') {
			//check if outlet already has an input
			if (shape.attrs.lineIn != null) {
				//POSSIBLE NEED TO DESTROY LINE ITSELF
				shape.attrs.lineIn.attrs.source.attrs.lineOut[shape.attrs.lineIn.attrs.sourceIndex].destroy();
			}
			shape.attrs.lineIn = currLine;
			currLine.attrs.outlet = shape;
			currLine.points()[2] = parent.x();
			currLine.points()[3] = parent.y() + shape.y();
			makingLine = false;
			shape.scale({	x: 1, y: 1 });
		} else if (shape.getParent() === currLine.attrs.source) {
			currLine.attrs.source.attrs.lineOut[currLine.attrs.source.attrs.lineOut.length - 1].destroy();
			currLine.destroy();
			makingLine = false;
		} // if clicked on a outlet, else clicked on self
		stage.draw();
	}
});

dragLayer.on('draw', function() {
	if(currShape != null) {
		var targetLine;
		for(var i = 0; i < currShape.children.length - 3; i++) {
			targetLine = currShape.children[i+3].attrs.lineIn;
			if(targetLine != null) {
				targetLine.points()[2] = currShape.x();
				targetLine.points()[3] = currShape.y() + currShape.children[i+3].y();
			}
		}
		for(var i = 0; i < currShape.attrs.lineOut.length; i++) {
			targetLine = currShape.attrs.lineOut[i];
			targetLine.points()[0] = currShape.x() + functionRectSideLength - 3;
			targetLine.points()[1] = currShape.y() + functionTotalSideLength / 2;
		}
		lineLayer.draw();
	}
});


</script>
</body>
<html>