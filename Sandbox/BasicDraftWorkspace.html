<!DOCTYPE HTML>
<html>
<head>
	<script>
	var width = 900;
	var height = 2 * width / 3;

	var functions = {
		add: 			{rep: '+', 	 max: 20, min: 2, index: 0},
		multiply: {rep: '*', 	 max: 20, min: 2, index: 1},
		negate: 	{rep: '-', 	 max: 1,  min: 1, index: 2},
		sine: 		{rep: 'sin', max: 1,  min: 1, index: 3},
		cosine: 	{rep: 'cos', max: 1,  min: 1, index: 4},
		absolute: {rep: 'abs', max: 1,  min: 1, index: 5},
		average: 	{rep: 'ave', max: 20, min: 2, index: 6},
		sign: 		{rep: 'sign',max: 1,  min: 1, index: 7},
		wrap: 		{rep: 'wrap',max: 1,  min: 1, index: 8},
		rgb: 			{rep: 'rgb', max: 3,  min: 3, index: 9}
	}

	var values = {
		x: 				{rep: 'x', 	 max: 20, min: 2, color: 'gray', 	index: 0},
		y: 				{rep: 'y', 	 max: 20, min: 2, color: 'gray', 	index: 1},
		second: 	{rep: 't.s', max: 1,  min: 1, color: 'gold', 	index: 2},
		minute:		{rep: 't.m', max: 1,  min: 1, color: 'gold', 	index: 3},
		hour: 		{rep: 't.h', max: 1,  min: 1,	color: 'gold', 	index: 4},
		day: 			{rep: 't.d', max: 1,  min: 1, color: 'gold', 	index: 5},
		constant:	{rep: '', 	 max: 20, min: 2, color: 'purple',index: 6},
	}
	</script>
	<style>
	body {
		margin: 0px;
		padding: 0px;
	} 
	#container {
		background-color: rgb(241, 248, 255);
		width: 900px;
		height: 600px;
	}
	</style>
</head>
<body>
	<div id="container"></div>
	<script src="http://d3lp1msu2r81bx.cloudfront.net/kjs/js/lib/kinetic-v5.1.0.min.js">
	</script>
	<script defer="defer">

	var stage = new Kinetic.Stage({
		container: 'container',
		width: width,
		height: height
	});


	// LAYERS
	var layer = new Kinetic.Layer();
	stage.add(layer);



	// CONSTRUCTORS

/*
	Function nodes and Value nodes are groups of objects. Members of groups can
	be accessed through the array 'group'.children[].
	Children are stored in the following order:
	0. Underlying Shape
	1. Text
	2+. Outlet nodes (only for functions)
	TODO: add render boxes in bottom-righthand corner, before Outlets
	*/


/* 
	makeFunctionGroup takes a string funName, a key in the functions object above,
	an integer x, and an integer y, and returns the corresponding function node object,
	with top right corner at the given x,y coordinate.
	*/
	var makeFunctionGroup = function(funName, x, y) {
		var minOutlets = functions[funName].min;
		var newGroup = new Kinetic.Group({
			name: funName,
			x: x - width / 180,
			y: y,
			numOutlets: 0,
			numInputs: 0,
			maxInputs: functions[funName].max,
			lineOut: [],
			funct: null,
			index: functions[funName].index
		});

		var newRect = new Kinetic.Rect({
			name: funName,
			x: width / 180,
			y: width / 180,
			width: width / 20 - width / 90,
			height: width / 20 - width / 90,
			fill: '#b6d7a8',
			lineJoin: 'round',
			stroke: '#b6d7a8',
			strokeWidth: width / 90
		});
		newGroup.add(newRect);

		var newText = new Kinetic.Text({
			text: functions[funName].rep,
			fontFamily: 'Open Sans',
			fill: 'black',
			fontSize: 16,
			x: 0,
			y: width / 40 - width / 180,
			width: width / 20,
			align: 'center'
		});
		newGroup.add(newText);

		var newBox = new Kinetic.Rect({
			x: functionBox.width() + 3,
			y: functionBox.height() + 3,
			width: width / 80,
			height: width / 80,
			fill: 'white',
			stroke: 'black',
			strokeWidth: .5
		});
		newGroup.add(newBox);

		var outlets = [];
		for (var i = 0; i < minOutlets; i++) {
			outlets[i] = makeOutlet(newGroup);
			newGroup.add(outlets[i]);
		}
		return newGroup;
	};


/*
	makeValueGroup takes a string valName, the name of a key in the values object above,
	an integer x, and an integer y, and returns the corresponding function node object,
	centered at (x + width / 40, y + width / 40).
	*/
	var makeValueGroup = function(valName, x, y) {
		var newGroup = new Kinetic.Group({
			name: valName,
			x: x,
			y: y,
			lineOut: [],
			index: values[valName].index
		});
		var newRect = new Kinetic.Rect({
			x: width / 40,
			y: 0,
			width: width / 28.3,
			height: width / 28.3,
			fill: values[valName].color,
			rotation: 45,
			name: valName
		});
		newGroup.add(newRect);
		var newText = new Kinetic.Text({
			text: valName,
			fontFamily: 'OpenSans',
			fill: 'black',
			fontSize: 16,
			x: 0,
			y: width / 56,
			width: width / 20,
			align: 'center'
		});
		newGroup.add(newText);
		var newBox = new Kinetic.Rect({
			x: width / 30,
			y: width / 30,
			width: width / 80,
			height: width / 80,
			fill: 'white',
			stroke: 'black',
			strokeWidth: .5
		});
		newGroup.add(newBox);
		return newGroup;
	};

/*
	makeOutlet takes a function node object, functGroup, and returns an outlet node object 
	to be added to that group, and increments numOutlets for that group.
	It DOES NOT add the outlet to the group.
	*/
	var makeOutlet = function(functGroup) {
		var bezPoint = width / 50;
		var outlet = new Kinetic.Shape({
			sceneFunc: function(context) {
				context.beginPath();
				context.moveTo(0, 0);
				context.bezierCurveTo(-bezPoint, -bezPoint, -bezPoint, bezPoint, 0, 0);
				context.closePath();
				context.fillStrokeShape(this);
			},
			name: 'outlet' + functGroup.attrs.numOutlets,
			x:functGroup.children[0].x()+ width/225,
			y:functGroup.children[0].y() + functGroup.attrs.numOutlets *
			((width/20 - 10) / 3) + width/180,
			fill: '#FFC440',
			stroke: 'black',
			strokeWidth: 1,
			lineIn: null
		});
		functGroup.attrs.numOutlets++;
		return outlet;
	};

	var makeLine = function(source) {
		var newLine = new Kinetic.Line({
			points: [
			source.x() + width / 20 - 3,
			source.y() + width / 40,
			source.x() + width / 20,
			source.y() + width / 40,
			],
			stroke: 'black',
			strokeWidth: 2,
			source: source,
			outlet: null
		});
		source.attrs.lineOut[source.attrs.lineOut.length] = newLine;
		return newLine;
	}


//METHODS

/*
	addOutlet takes a function group funGroup and adds an outlet to it, expanding the node if there is not enough space for the outlet.
	*/
	var addOutlet = function(funGroup) {
		if(funGroup.attrs.numOutlets < funGroup.attrs.maxInputs) {
			if(funGroup.attrs.numOutlets > 2) {
				funGroup.children[0].setAttr('height',
					funGroup.children[0].attrs.height + width / 60 - 3.3);
				funGroup.children[1].setAttr('y', funGroup.children[1].attrs.y + width / 120 - 1.67);

			}
			var newOutlet = makeOutlet(funGroup);
			funGroup.add(newOutlet);
			stage.draw();
		}
	};




	stage.on('contentDblclick', function() {
		var newFunct = makeFunctionGroup('add', stage.getPointerPosition().x,
			stage.getPointerPosition().y);
		layer.add(newFunct);
		layer.draw();
	});

	layer.on('click', function(evt) {
		var parent = evt.target.getParent();
		addOutlet(parent);
	});

	</script>
</body>
<html>